# X-ray

The main idea behind x-ray is it reads traces sent from your application and AWS services. The traces go to an x-ray UDP Daemon, which sends to X-Ray in batches. 

A `segment` is a bit of work done, e.g. an endpoint that was called, start/end times, errors thrown. A `subsegment` is a segment that falls under another segment.
The main way x-ray can define a `service graph` is by recording api calls. E.g., when Service A has X-ray configured, and it calls DynamoDB, X-ray will automatically define a `subsegment` for the dynamodb call. Same for other stuff, e.g. an `API Gateway` will automatically generate `subsegments` for resources it calls. Those subsegments can create more subsegments if they have x-ray configured themselves.

A tracing header is automatically passed to most requests: `X-Amzn-Trace-Id: Root=x-xxx-xxxx;Sampled=1` that the X-Ray SDK can pick up and use.

A `trace` is a collection of all segments generated by a single request. By default, X-ray only collects the first request each second, and 5% of all other requests. You can also create filter expressions to collect traces belonging to certain users or other stuff.

Groups are ways to divide traces into groups. E.g. you can make a group where the endpoint was x and the responsetime was >5 seconds

Annotations are additional fields added to a segment. E.g. you can add responsetime, username, etcetera as annotations. These annotations can be used to make filter expressions (to define which traces are collected), make groups, etcetera.

Metadata are similar to annotations, but *not indexed*, and cannot be used to search or filter on. Basically if you want to store stuff for debugging but not search on it.

## Lambda

To use x-ray in lambda, you have to add the following code (python example):

`from aws_xray_sdk.core import patch_all; patch_all()`

Lambda is smart enough that it will record info like execution time by itself. There are three environment variables related to X-ray in lambda:

- `_X_AMZN_TRACE_ID`: contains the trace_id header, or if it wasn't passed, xray package will generate a trace id automatically and set it to this variable.
- `AWS_XRAY_CONTEXT_MISSING` - influence behavior when no trace_id was passed. default is `LOG_ERROR`
- `AWS_XRAY_DAEMON_ADDRESS` - contains the xray-daemon adress. Only used for sending data to the xray-daemon directly (don't do this unless you are crazy)

## X-ray SDK

*Important* you must be running the X-ray daemon somewhere, X-ray doesn't just work magically, you have to pay for the daemon. (Edit: I think you can also call the 'PutTrace' api yourself, but it's more complicated?) Also, you must be able to communicate with the daemon on port 2000, UDP. If you want, in EC2 or ECS, you can run the x-ray daemon on localhost, in which case you don't need to open port 2000.

Used in your own applications, e.g. EC2 or ECS. Works like:

```
from aws_xray_sdk.core import xray_recorder
from aws_xray_sdk.core import patch_all

xray_recorder.configure(service='My app name')
plugins = ('EC2Plugin', ) # ECS, EKS, Beanstalk, EC2
xray_recorder.configure(plugins=plugins)
patch_all()
```

In the plugins you define where it's running. This is mostly used so it knows what data to collect and how, e.g. cpu, memory, etc.

There are other environment variables:

- The ones listed above for lambda
- `AWS_XRAY_TRACING_NAME` - set the service name used to name the segments
- `PLUGINS` - contains the list of plugins (set by the code above)
- `SAMPLING_RULES` - define sampling rules. Default is first every second, 5% of the others.

## Read results

To read the x-ray results, you can either use the AWS website, or you can read the traces with `GetTraceSummaries` and `BatchGetTraces`. The first is like an S3 `list` operation that just gets the trace IDs, the second one actually gets the traces, given the IDs.